# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

import django.urls
from django.conf import settings

from lib.l10n_utils import translation


class LocalePrefixPattern(django.urls.LocalePrefixPattern):
    """
    A sub-class of Django's "LocalePrefixPattern" that simply normalizes the language
    prefix for Bedrock (e.g., upper-case country codes).

    This is an essential piece, since it controls the resolution of the
    language-code prefix of incoming URLs as well as the language code prefix
    of the URLs generated by Django's "reverse".
    """

    @property
    def language_prefix(self):
        language_code = normalize_language(translation.get_language()) or settings.LANGUAGE_CODE
        if language_code == settings.LANGUAGE_CODE and not self.prefix_default_language:
            return ""
        return f"{language_code}/"


def bedrock_i18n_patterns(*urls, prefix_default_language=True):
    """
    Similar to Django's i18n_patterns but uses out "LocalePrefixPattern", defined above
    """
    if not settings.USE_I18N:
        return list(urls)
    return [
        django.urls.URLResolver(
            LocalePrefixPattern(prefix_default_language=prefix_default_language),
            list(urls),
        )
    ]


def normalize_language(language):
    """
    Given a language code, returns the language code supported by Bedrock in the
    proper case, for example "eN-us" --> "en-US" or "sC" --> "it", or None if
    SUMO doesn't support the language code.
    """
    if not language:
        return None

    lang, partition, territory = language.partition("-")
    if territory:
        lc_language = f"{lang}-{territory}"
    else:
        lc_language = lang
    return settings.LANGUAGE_MAP_WITH_FALLBACKS.get(lc_language)


def find_supported(lang):
    # lang = lang.lower()
    if lang in settings.LANGUAGE_MAP_WITH_FALLBACKS:
        return settings.LANGUAGE_MAP_WITH_FALLBACKS[lang]
    pre = lang.split("-")[0]
    if pre in settings.LANGUAGE_MAP_WITH_FALLBACKS:
        return settings.LANGUAGE_MAP_WITH_FALLBACKS[pre]


def split_path(path_):
    """
    Split the requested path into (locale, path).

    locale will be empty if it isn't found.
    """
    path = path_.lstrip("/")

    # Use partition instead of split since it always returns 3 parts
    first, _, rest = path.partition("/")

    supported = find_supported(first)
    if supported:
        return supported, rest
    else:
        return "", path
